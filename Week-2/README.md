# Week-2: Advanced Java Development & Database Programming

## Overview
This week focused on three key areas of software development:
1. **SLF4J Logging Framework** - Implementing proper logging practices
2. **Test-Driven Development (TDD) with JUnit5 and Mockito** - Writing effective unit tests
3. **PL/SQL Programming** - Database programming with Oracle PL/SQL

## 🎯 Learning Objectives Achieved

### 1. SLF4J Logging Framework
- **Understanding Logging Levels**: Mastered different logging levels (ERROR, WARN, INFO, DEBUG) and their appropriate usage
- **SLF4J Integration**: Successfully integrated SLF4J with Logback as the logging implementation
- **Best Practices**: Learned proper logging practices for production applications
- **Configuration**: Understood how to configure logging frameworks in Maven projects

### 2. Test-Driven Development (TDD) with JUnit5 and Mockito
- **JUnit5 Setup**: Configured JUnit5 in Maven projects and IntelliJ IDEA
- **Test Structure**: Mastered the Arrange-Act-Assert (AAA) pattern for writing clear, maintainable tests
- **Assertions**: Utilized various JUnit5 assertions for comprehensive test coverage
- **Mockito Integration**: Implemented mocking and stubbing techniques for isolated unit testing
- **Test Verification**: Learned to verify method interactions and behavior using Mockito
- **TDD Workflow**: Practiced the Red-Green-Refactor cycle of Test-Driven Development

### 3. PL/SQL Programming
- **Control Structures**: Implemented IF-THEN-ELSE, CASE statements, and loops
- **Error Handling**: Created robust error handling with EXCEPTION blocks
- **Stored Procedures**: Developed reusable stored procedures for business logic
- **Functions**: Built custom functions for data manipulation and calculations
- **Triggers**: Implemented database triggers for automated data validation and updates
- **Cursors**: Utilized cursors for processing result sets
- **Packages**: Organized PL/SQL code using packages for better modularity

## 📁 Project Structure

```
Week-2/
├── Week2_SLF4J logging framework/
│   └── Exercise 1 - Logging Err msgs And Warning Levels/
│       ├── src/main/java/org/sudip/logging/Logging.java
│       ├── pom.xml
│       └── README.md
├── Week2_TDD using JUnit5 and Mockito/
│   ├── Exercise 1 - Setting Up JUnit/
│   ├── Exercise 3 - Assertions in JUnit/
│   ├── Exercise 4 - Arrange-Act-Assert (AAA) Pattern/
│   ├── Mockito Exercise 1 - Mocking and Stubbing/
│   └── Mockito Exercise 2 - Verifying Interactions/
└── week2-Pl Sql/
    ├── Exercise 1 Control Structures/
    ├── Exercise 2 Error Handling/
    ├── Exercise 3 Stored Procedures/
    ├── Exercise 4 Functions/
    ├── Exercise 5 Triggers/
    ├── Exercise 6 Cursors/
    └── Exercise 7 Packages/
```

## 🛠️ Technologies & Tools Used

### Java Development
- **Java**: JDK 21
- **Build Tool**: Maven
- **IDE**: IntelliJ IDEA Ultimate
- **Testing Framework**: JUnit 5
- **Mocking Framework**: Mockito
- **Logging Framework**: SLF4J with Logback

### Database Development
- **Database**: Oracle Database
- **Language**: PL/SQL
- **Tools**: SQL*Plus / Oracle SQL Developer

## 📚 Key Learnings & Skills Developed

### Logging Best Practices
- Understanding the importance of proper logging in production applications
- Choosing appropriate log levels for different scenarios
- Configuring logging frameworks for different environments
- Using structured logging for better debugging and monitoring

### Testing Excellence
- Writing comprehensive unit tests that cover edge cases
- Using mocks to isolate units under test
- Following TDD principles for better code quality
- Understanding test coverage and its importance
- Implementing proper test organization and naming conventions

### Database Programming
- Writing efficient PL/SQL code for business logic
- Implementing proper error handling in database procedures
- Using database triggers for data integrity
- Creating reusable database components with packages
- Understanding cursor-based data processing

## 🎓 Practical Applications

### Real-World Scenarios Covered
1. **Logging**: Application monitoring and debugging in production environments
2. **Testing**: Ensuring code quality and preventing regressions in enterprise applications
3. **Database**: Building robust data processing pipelines and business logic

### Industry Best Practices
- Following SOLID principles in test design
- Implementing comprehensive logging strategies
- Writing maintainable and scalable database code
- Using version control and proper project structure

## 🚀 Next Steps
- Explore advanced logging configurations and log aggregation
- Practice integration testing with Spring Boot
- Learn about database performance optimization
- Implement continuous integration with automated testing

---

